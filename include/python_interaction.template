#ifndef @CLASSNAME_H_
#define @CLASSNAME_H_

#include <Eigen/Dense>
#include <vector>

#include "particle_system.hpp"
#include "parameter_list.hpp"
#include "twobody.hpp"
#include "vec3.h"
#include "math.h"

/* @WARNING_TEXT */

class @CLASSNAME : public TwoBodyInteraction {
    public:
        @CLASSNAME(unsigned int pi, unsigned int pj, ParameterList pList)
            : TwoBodyInteraction(pi,pj)
        {
            if (pList.getTotalParameters() != n_param) {
                std::cerr << "ERROR::@CLASSNAME::@CLASSNAME: Wrong number of initial parameters" << std::endl;
            }
            if (pList.getDiffParameters() != n_diff_param) {
                std::cerr << "ERROR::@CLASSNAME::@CLASSNAME: Wrong number of diff parameters" << std::endl;
            }
            allParameters = pList;
            parameter_indexs = pList.getIndexVector();
        }
    private:
        int n_diff_param = @NUMBER_OF_DIFF_PARAMETERS;
        int n_param = @NUMBER_OF_PARAMETERS;
        ParameterList allParameters;

        double energy() const override {
            double E = @ENERGY_CALCULATION;
            return E;
        }

        vec3 force() const override {
            double f[3][1] = @FORCE_CALCULATION;
            return vec3(f[0][0], f[1][0], f[2][0]);
        }

        Eigen::Matrix3d force_position_derivative() const override {
            double df_dx[3][3] = @FORCE_POSITION_DERIVATIVE_CALCULATION;
            Eigen::Matrix3d result;
            result << df_dx[0][0], df_dx[0][1], df_dx[0][2],
                      df_dx[1][0], df_dx[1][1], df_dx[1][2],
                      df_dx[2][0], df_dx[2][1], df_dx[2][2];
            return result;
        }

        virtual Eigen::Matrix3d force_velocity_derivative() const override {
            double df_dv[3][3] = @FORCE_VELOCITY_DERIVATIVE_CALCULATION;
            Eigen::Matrix3d result;
            result << df_dv[0][0], df_dv[0][1], df_dv[0][2],
                      df_dv[1][0], df_dv[1][1], df_dv[1][2],
                      df_dv[2][0], df_dv[2][1], df_dv[2][2];
            return result;
        }

        virtual Eigen::MatrixXd force_parameters_derivative() const override {
            Eigen::MatrixXd result(3, n_diff_param);
            double df_dp[3][@NUMBER_OF_DIFF_PARAMETERS] = @FORCE_PARAMETERS_DERIVATIVE_CALCULATION;
            for (unsigned int i = 0; i < 3; i++) {
                for (unsigned int j = 0; j < n_diff_param; j++) {
                    result(i,j) = df_dp[i][j];
                }
            }
            return result;
        }
};

#endif // @CLASSNAME_H_
